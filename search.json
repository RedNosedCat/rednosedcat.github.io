[{"title":"Screen指令","url":"/2024/01/16/Screen指令/","content":"\n### 简介\nScreen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换\n\n<!--more-->\n\n### 安装\n```Bash\nyum install screen\n```\n\n### 使用\n\n- ### 新建会话\n\n- ### 1. 新建一个叫yourname的session\n```Bash\nscreen -S yourname\n```\n- ### 2. 列出当前所有的session\n```Bash\nscreen -ls\n```\n- ### 3. 恢复会话（回到yourname这个session）\n```Bash\nscreen -r yourname\n```\n- ### 4. detach某个session\n```Bash\nscreen -d yourname -> 远程detach某个session \nscreen -d -r yourname -> 结束当前session并回到yourname这个session\n```\n- ### 5. 删除会话\n```Bash\nscreen -S pid-X quit\n```\n\n- ### 6. 返回主终端(组合键得同时按下去)\n```Bash\n- Ctrl+a 在按d \n- Ctrl+a+d\n```\n\n- ### 7. 退出当前终端(结束任务)\n```Bash\nexit\n```\n","tags":["Linux"],"categories":["Linux"]},{"title":"PHP导出csv","url":"/2024/01/16/PHP导出csv/","content":"\n### PHP生成csv文件\n<!--more-->\n- 换行可以用\\n\n```php\necho $v.\"\\n\";\n```\n\n- 输出字符串,在内容输出后加一个字符即可输出字符串\n```php\necho '游戏包'.',';\n```\n#### 代码示例\n```php\nfunction setExportHeader($fileName , $type = 'txt')\n{\n    if($type == 'excle'){\n        header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');\n    } else  {\n        header('Content-Type: application/octet-stream');\n    }\n\n    header('Content-Disposition: attachment;filename=' . $fileName);\n    header('Cache-Control: max-age=0');\n    header('Cache-Control: max-age=1');\n    header ('Expires: Mon, 26 Jul 1997 05:00:00 GMT');\n    header ('Last-Modified: '.gmdate('D, d M Y H:i:s').' GMT');\n    header ('Cache-Control: cache, must-revalidate');\n    header ('Pragma: public');\n}\n\nsetExportHeader('file.csv');\n\necho '第一列'.',';\necho '第二列'.',';\n\nforeach($arr as $k=>$v)\n{\n    echo $v['line1'].\",\";\n    echo $v['line2'].\"\\n\";\n}\n\n```","tags":["PHP"],"categories":["PHP"]},{"title":"PHP导入csv","url":"/2024/01/16/PHP导入csv/","content":"\n### PHP读取csv文件\n<!--more-->\n#### 代码示例\n```php\nfunction getFileData($file , $type = 1)\n{\n    $res = [];\n    if (!is_file($file)) {\n        exit('没有文件');\n    }\n\n    $handle = fopen($file, 'r');\n    if (!$handle) {\n        exit('读取文件失败');\n    }\n\n    while (($data = fgetcsv($handle)) !== false) {\n        // 下面这行代码可以解决中文字符乱码问题\n        $data[0] = iconv('gbk', 'utf-8', $data[0]);\n\n        // 跳过第一行标题\n        if ($data[0] == '用户ID') {\n            continue;\n        }\n\n        $arr = [];\n        $arr['test'] = $data[0];\n        \n     \n        $res[] = $arr;\n    }\n\n    fclose($handle);\n    return $res;\n}\n\n$arr = getFileData('./test.csv');\n```\n","tags":["PHP"],"categories":["PHP"]},{"title":"flex布局","url":"/2024/01/16/flex布局/","content":"\n### 左右结构flex布局\n![BP](flex布局/flex.png)\n<!--more-->\n\n### css样式\n\n```css\n.layout-flex{\n    width:100%;\n    overflow: hidden;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height:1rem;\n}\n.item1{\n    width:20%;\n}\n.item2{\n    width:50%;\n}\n.item3{\n    width:30%;\n}\n```\n\n### 布局\n\n```css\n<div class=\"layout-flex\">\n    <div class=\"item1\"></div>\n    <div class=\"item2\"></div>\n    <div class=\"item3\"></div>\n</div>\n```\n","tags":["web","css","html"],"categories":["web"]},{"title":"input占位符样式修改","url":"/2024/01/16/input占位符样式修改/","content":"\n### input占位符样式调整\n\n```css\ninput::-webkit-input-placeholder, textarea::-webkit-input-placeholder {\n    color: #F97D72;\n}\n```","tags":["web","css","html"],"categories":["web"]},{"title":"滚动条样式自定义","url":"/2024/01/16/滚动条样式自定义/","content":"###  css隐藏滚动条\n```css\n::-webkit-scrollbar{\n    width:0;\n    height:0;\n}\n```\n\n<!--more-->\n\n### 隐藏滚动条的样式对某个类失效\n```css\n:not(.activity-rule)::-webkit-scrollbar {\n    width:0;\n    height:0;\n}\n```\n\n### 调整滚动条背景样式\n```css\n::-webkit-scrollbar{\n    width:6px;\n    border-radius:10px;\n    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);\n}\n```\n\n### 调整滚动条小滑块样式\n```css\n::-webkit-scrollbar-thumb{\n    background: #FFEFA9;\n    border-radius: 10px;\n}\n```\n","tags":["web","css","html"],"categories":["web"]},{"title":"explain关键词","url":"/2021/12/25/EXPLAIN关键词返回的字段描述/","content":"Explain关键词返回字段描述\n<!--more-->\n### Explain关键字\n可以查看mysql的执行过程\n\n| id | select_type | table | type | possible_keys | key | key_len | ref | rows | extra |\n| :-----| :----: | :----: |:----: |:----: |:----: |:----: |:----: |:----: |:----: |\n| 1 | SIMPLE | udid_info |ALL |  |  |  |  | 4900945  |  |\n\nselect_type字段值概述：(select类型)\n```angular2\n    SIMPLE  :   简单SELECT(不使用UNION或子查询)\n    PRIMARY :   最外面的select\n    UNION   :   UNION中的第二个或后面的SELECT语句\n    DEPENDENT UNION: UNION中的第二个或后面的SELECT语句,取决于外面的查询\n    UNION RESULT: UNION的结果\n    SUBQUERY:   子查询中的第一个select\n    DEPENDENT SUBQUERY: 子查询中的第一个select,取决于外面的查询\n    DERIVED :   导出表的select\n```\n    \ntable字段:\n\n返回行所在的表名\n\n\ntype字段值概述:(链接类型,按照从最佳类型到最坏类型进行排序：)\n```angular2\n    system  : 仅有一行数据的表(系统表)\n    const   : 表最多有一个匹配行，在查询开始前被读取\n    eq_ref  : \n    ref     :   \n    index_merge : 该联接类型表示使用了索引合并优化方法\n    unique_subquery : 是一个索引查找函数，可以完全替换子查询，效率更高。\n    index_subquery : 同unique_subquery可以替换IN子查询，但只适合子查询中的非唯一索引\n    range   :   范围查找\n    index   :   该联接类型与ALL相同，除了只有索引树被扫描\n    ALL     :   全表扫描            \n\n```\npossible_keys：\n\npossible_keys列指出MySQL能使用哪个索引在该表中找到行\n#\nkey：\n\nkey列显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX\n#\nkey_len\n\nkey_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。注意通过key_len值我们可以确定MySQL将实际使用一个多部关键字的几个部分。\n#\nref\n\nref列显示使用哪个列或常数与key一起从表中选择行。\n#\n rows\n \nrows列显示MySQL认为它执行查询时必须检查的行数。\n#\n Extra\n\n该列包含MySQL解决查询的详细信息\n```angular2\n    Distinct\n    Not exists\n    range checked for each record\n    Using filesort\n    Using index\n    Using temporary\n    Using where\n    Using sort_union(...), Using union(...), Using intersect(...)\n    Using index for group-by\n```    ","tags":["mysql"],"categories":["mysql"]},{"title":"php面试题","url":"/2021/12/25/php面试题/","content":"php面试题整理\n<!--more-->\n### 1.什么是面向对象?主要特征是什么?\n```\n面向对象是程序的一种设计方式,提高程序重用性，使程序结构更加清晰。\n\n主要特征:封装、继承、多态\n```\n\n### 2.SESSION和COOKIE的区别是什么，请从协议和，产生的原因和作用说明？\n```\n1.协议方面：http无状态协议，不能区分用户是否从同一个网站上来的，同一个用户请求不同的页面不能看作是同一个用户。\n\n2.SESSION存储在服务端，COOKIE存储在客户端。SESSION相对于安全点，COOKIE用某些手段可以篡改。SESSION依赖于COOKIE进行传递。禁用COOKIE后SESSION不能正常使用。\n```\n\n### 3.HTTP协议中302、403、500状态码的含义?\n```\n一二三四五原则:\n一、消息系列 \n二、成功系列 \n三、重定向系列 \n四、请求错误系列 \n五、服务器端端错误系列\n302临时转移成功、403禁止访问、500服务器内部错误\n```\n\n### 4.LINUX建立压缩包，解压缩包的命令\n```\nTar.gz:\n打包：tar czf file.tar.gz file.txt\n解压：tar xzf  file.tar.gz\n\nBz2:\n打包：bzip 2 [-k]  文件\n解压：bunzip2  [-k] 文件\n\nGzip:(只对文件，不保留原文件)\n打包：gzip file1.txt\n解压: gunzip file1.txt.gz\n\nZip:-r(对目录)\n打包：zip file1.zip\n解压：unzip file.zip\n```\n### 5.请写出数据类型(int char varchar datetime text)的意思；请问 varchar 和 char有什么区别？();\n```\nint:整形 \nchar:固定长度字符串 \nvarchar:可变长度字符串 \ndatetime:日期时间格式 \ntext:文本型\n\nvarchar和char的区别:char是固定长度的字符串类型，分配多少空间，就会占用多少空间。Varchar是可变型字符串类型，内容有多大就占用多大空间，能有效节省空间。由于varchar类型是可变的，所以在数据长度改变时，服务器需要进行额外操作，所以效率比char类型低\n```\n\n### 6. MyISAM 和 InnoDB 的基本区别？索引结构如何实现？\n```\nMyISAM类型不支持事务、表锁，易产生碎片化，要经常优化，读写速度较快。InnoDB类型支持事务，行锁，有崩溃恢复能力，读写速度比MyISAM慢。\n\nMyISAM支持表锁不支持行锁，InnoDB表锁和行锁都支持。\n\n创建索引:alert table tablename add index ('字段名')\n```\n### 7.isset()和empty()的区别\n```\nisset()检测变量是否存在，可以传入多个变量,若其中一个不存在则返回假，empty()检测变量是否为空，只可传入一个变量，如果为空为假则返回真\n```\n\n### 8.如何在页面之间传递变量(至少两种方式)?\n```\nGET,POST,COOKIE,SESSION，隐藏表单\n```\n\n### 9.请写出常见的排序算法？并用PHP实现冒泡排序，将数组$array = ()按照从小到大的方式进行排序。\n```\n常见的排序算法有：冒泡排序法、快速排序法、简单选择排序法、堆排序法、直接插入排序法、希尔排序法、合并排序法\n冒泡排序法的基本思想是：对排序记录关键字从后往前，进行多次扫描，当发现两个相邻的关键字不满足排序规则时，就将这两个关键字进行位置交换。这样关键字较小的记录将会逐渐从后面像前面移动。\n\n//冒泡排序\nfunction mp_sort($arr){\n    $arrayLength = count($arr);\n    for($i = 0; $i < $arrayLength; $i++){\n        for($j = $i+1 ; $j < $arrayLength; $j++){\n            if($arr[$j] < $arr[$i]){\n                $value = $arr[$i];\n                $arr[$i] = $arr[$j];\n                $arr[$j] = $value;\n            }\n        }\n    }\n\n    return $arr;\n}\n\n$arr = [1 , 3 , 5 , 7 , 9 , 8 , 6];\n$res = mp_sort($arr);\n```\n\n### 10.请说明PHP中引用与传值的区别？什么时候用引用什么时候用传值？\n```\n传值：函数范围内对值的任意改变都会被函数外部所忽略\n引用：函数内部对值的改变在函数外部也能反映出来\n\n按值传递，php必须进行赋值，对于特别大的字符串或者对象来说，这将会是一个代价很大的操作，按引用传递，则不需要赋值，可以节省内存开销,对于性能提高很有好处，但是每次值的改变，都会影响到原来的变量。\n```\n\n### 11.请简述一下数据库优化？\n```\n从结构层:web服务器采用负载均衡，mysql服务器采用主从复制，读写分离\n从储存层：采用合适的存储引擎\n从设计层：采用分区分表，索引，表的字段采用合适的属性，开启mysql缓存\nsql语句层：优化查询语句\n```\n\n### 12.如何解决异常处理？\n```\n抛出异常，使用try...catch，异常的代码放到try代码块，如果没有出发异常，代码继续执行，如果异常被触发，就会抛出一个异常.Catch代码块捕获异常，并创建一个包含异常的对象，$->getMessage(),输出异常的错误信息。\n```\n\n### 13.怎么保证促销商品不会超卖？\n```\n数据库锁，高并发时会对数据库的性能影响很大；\n文件锁，会导致大量的I/O操作\n可以采用Redis队列实现，将要促销的商品数量以队列的方式存入redis中，每当用户抢到一件促销商品时则从队列中删除一个数据，确保商品不会超卖。操作简单，而且效率极高\n```\n\n### 14.商城秒杀的实现？\n```\n抢购、秒杀场景需要解决的主要问题有两个：高并发对数据库产生的压力、竞争状态下如何解决库存的正确减少\n高并发方面：可以采用数据缓存来处理抢购，避免直接操作数据库\n库存方面：可以采用队列方式，把要秒杀的商品存放到队列中，因为pop操作时原子性的，即使有很多用户同时到达，也是依次执行，文件锁和事务在高并发的情况下性能下降很快；\n```\n\n### 15.laravel框架有哪些特色?\n```\n laravel框架的设计思想比较先进，非常适合应用各种开发模式，Laravel框架的最大特点和优秀之处就是集合了PHP比较新的特点，以及各种各样的设计模式，loc模式，依赖注入模式等\n   artisan：命令行工具，很多手动的工作都自动化\n   可继承的模板：简化view的开发和管理\n   blade模板：渲染速度更快\n   ORM操作数据库\n   migrate：管理数据库和版本控制\n   测试功能也很强大\n   composer也是亮点\n```\n\n### 16.为什么使用Laravel框架，他有什么好处，为什么不用其他框架?\n```\n能快速开发功能，自带各种方便的服务，比如数据验证、队列、缓存、数据迁移、测试、artisan命令行等，还有强大的ORM\n```\n\n### 17.写出一个能创建多级目录的PHP函数\n```\nfunction makeDir($dirName , $auth){\n    if(is_dir($dirName)){\n        echo '目录已经存在';\n    } else {\n        $res = make_dir($dirName , $auth , true);\n        if($res){\n            echo '创建目录成功';\n        } else {\n            echo '创建目录失败';\n        }\n    }\n}\n\nmakeDir('./a/b' , 0755);\n```\n\n### 18.MySql的索引有哪些?\n```\nMySQL目前主要有的索引类型为：普通索引、唯一索引、主键索引、组合索引、全文索引。\n```\n\n### 19.php的八种变量类型\n```\nint、bool、string、array、resource、null、float、object\n```\n\n### 20.Redis支持五种数据类型:\n```\n分别是string 字符串(key=>value)、hash 哈希(key=>对象)、list 列表(队列)、set 集合()、zset有序集合\n\nString（字符串）\nstring 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。\nstring 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。\nstring 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。\n常用命令：set、get、decr、incr、mget等。\n注意：一个键最大能存储512MB。\n\nHash（哈希）\nRedis hash 是一个键值(key=>value)对集合；是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。\n每个 hash 可以存储 232 -1 键值对（40多亿）。\n常用命令：hget、hset、hgetall等。\n应用场景：存储一些结构化的数据，比如用户的昵称、年龄、性别、积分等，存储一个用户信息对象数据。\n\nList（列表）\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\nlist类型经常会被用于消息队列的服务，以完成多程序之间的消息交换。\n常用命令：lpush、rpush、lpop、rpop、lrange等。\n列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。\n\nSet（集合）\nRedis的Set是string类型的无序集合。和列表一样，在执行插入和删除和判断是否存在某元素时，效率是很高的。集合最大的优势在于可以进行交集并集差集操作。Set可包含的最大元素数量是4294967295。\n集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。\n应用场景：\n1、利用交集求共同好友。\n2、利用唯一性，可以统计访问网站的所有独立IP。\n3、好友推荐的时候根据tag求交集，大于某个threshold（临界值的）就可以推荐。\n常用命令：sadd、spop、smembers、sunion等。\n集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。\n\nzset(sorted set：有序集合)\nRedis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。\n不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。\nzset的成员是唯一的,但分数(score)却可以重复。\nsorted set是插入有序的，即自动排序。\n常用命令：zadd、zrange、zrem、zcard等。\n当你需要一个有序的并且不重复的集合列表时，那么可以选择sorted set数据结构。\n应用举例：\n（1）例如存储全班同学的成绩，其集合value可以是同学的学号，而score就可以是成绩。\n（2）排行榜应用，根据得分列出topN的用户等。\n```\n\n### 21.php中静态变量的和普通变量的区别\n```\n在普通变量之前加上static关键字就构成了静态变量,静态变量只会初始化一次,静态变量的声明不能用表达式，类似于static $a = 1+2这种;需要直接复制static $ = 1;作用域为局部作用域\n```\n\n### 22.为什么会产生跨域问题?\n```\n跨域问题来源于JavaScript的同源策略，即只有 协议+主机名+端口号(如存在)相同，则允许相互访问。也就是说JavaScript只能访问和操作自己域下的资源，不能访问和操作其他域下的资源。跨域问题是针对JS和ajax的，html本身没有跨域问题，比如a标签、script标签、甚至form标签\n\n1.浏览器限制 \n2.跨域(域名、端口不一样都是跨域问题) \n3.XHR(XMLHttpRequest请求)\n```\n\n### 23.解决跨域问题方案\n```\n1.允许浏览器跨域访问 \n\n2.jsonP\n\n3.服务端方面解决:  服务器实现需要注意两种情况，简单请求和非简单请求。简单请求是先执行请求再验证，非简单请求是先验证再请求。\n\n简单请求（比较常见）：方法为get，head，post,请求header里面没有自定义头，Content-Type的值为以下几种 text/plain,multipart/form-data,application/x-www-form-urlencoded。\n非简单请求（比较常见）：put,delect方法的ajax请求，发送json格式的ajax请求，带自定义头的ajax请求。\n简单请求处理方案：在响应头中添加\n\nAccess-Control-Allow-Origin=“允许跨域的url”，即跨省域时，请求头Origin的值，所以一般是获取Origin的值。\nAccess-Control-Allow-Method=“*”，允许的方法。\n\n非简单请求处理方案：在相应头中添加\nAccess-Control-Allow-Origin=“允许跨域的url”，即跨域时，可以获取请求头Origin的值。\nAccess-Control-Allow-Method=“*”，允许的方法\nAccess-Control-Request-Headers=“Content-Type,自定义的header的key”。\n\n带cookies的跨域解决：在响应头添加\nAccess-Control-Allow-Credentials,=\"true\"，允许使用cookies\n```\n\n### 24.redis缓存穿透，缓存击穿，缓存雪崩原因+解决方案\n```\n没搞明白，可以参考一下：https://www.cnblogs.com/xichji/p/11286443.html\n```\n\n### 25.git相关的面试题\n\n### 26.linux相关的面试题\n```\n大概就是常用的linux命令\n```\n\n### 27.系统运行出错后去哪里看日志，怎么看日志，排错思路\n\n### 28.mysql慢查询应该怎么解决，怎么获取慢查询sql","tags":["PHP","面试题"],"categories":["面试题"]},{"title":"git生成SSH公钥","url":"/2021/04/20/git生成SSH公钥/","content":"1.配置用户名\n\n```angular2\ngit config --global user.name \"liudongdong2\"\n```\n<!--more-->\n\n2.配置邮箱\n```angular2\ngit config --global user.email \"1612043566@qq.com\"\n```\n\n3.C:\\Users\\1612043566目录下生成.gitconfig配置文件\n\n4.ssh-keygen -t rsa -C \"1612043566@qq.com\",生成公钥和私钥,按3次Enter;\n可以在C:\\Users\\1612043566目录下生成\\.ssh下的id_rsa.pub查看公钥\n","categories":["Git"]},{"title":"yum源安装指定版本的Lnmp环境","url":"/2021/04/12/yum源安装指定版本的Lnmp环境/","content":"1.nginx安装目前就用yum包里边自带的版本,不会起冲突\n<!--more-->\n安装过程和上篇文章一致\n\n2.PHP则安装7.0版本\n```angular2\n安装源：\n# rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm\n# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm\n\n安装php7：\n# yum install php70w\n\n安装php7-mysql\n#yum install php70w-mysql\n\n如果上述命令除了问题,可以试试卸载PHP5.14版本和扩展的旧安装包\n# rpm -e php-common-5.4.16-46.el7.x86_64 php-cli-5.4.16-46.el7.x86_64 php-pdo-5.4.16-46.el7.x86_64 php-5.4.16-46.el7.x86_64 php-mysql-5.4.16-46.el7.x86_64\n\n卸载完之后把安装好的php-fpm,php-mysql都卸载了，在重新安装一次\n# yum remove php-fpm\n# yum remove php\n# yum remove php-mysql\n\n输入php -v 查看php的版本是否输出正确\n\n参考文档：https://www.51anidea.com/forum.php?mod=viewthread&tid=1255\n```\n\n3.Mysql安装5.7版本\n```angular2\n安装mysql源\n# wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm\n\n继续输入命令\n# rpm -ivh mysql80-community-release-el7-3.noarch.rpm\n\n修改yum源默认安装的版本\n# vim /etc/yum.repos.d/mysql-community.repo\n修改yum配置（enabled=1 想要安装哪个版本就在哪个版本的后面把0换成1)\n\n安装\nyum install mysql-community-server\n\n参考文档：https://www.cnblogs.com/black-fact/p/10840332.html\n```\n\nyum命令参考：https://xiaohost.com/1860.html","tags":["面试题"],"categories":["环境搭建","面试题","Linux"]},{"title":"Git常用命令","url":"/2021/04/10/Git常用命令/","content":"Git的常用命令\n<!--more-->\n1.初始化仓库\n```angular2\ngit init\n```\n\n2.添加文件到缓存区\n```angular2\ngit add filename\n```\n\n3.提交文件\n```angular2\ngit commit -m 提交说明\n```\n\n4.查看git状态\n```angular2\ngit status\n```\n\n5.查看修改文件\n```angular2\ngit diff\n```\n\n6.查看提交记录,从最近到最远\n```angular2\ngit log\ngit log --pretty=oneline    //只显示提交时候编辑的内容\n```\n\n7.版本回退\n\nGit必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n\n版本号ID就是git log命令显示出来的左侧的字符串\n\n```angular2\ngit reset --hard HEAD^\ngit reset --hard 版本号\n```\n\n8.查看命令历史，以便确定要回到未来的哪个版本。\n\n可以找到之前的版本\n```angular2\ngit reflog\n```\n\n9.撤回工作区的修改\n\n撤回工作区的修改，还原成和缓存区的内容一样\n```angular2\ngit checkout -- file\n```\n\n10.撤回缓存区的修改，把撤回的内容重新放回到工作区\n```angular2\ngit reset HEAD <file>\n```\n\n11.删除文件\n```angular2\ngit rm test.txt\n```\n\n12.本地关联远程仓库\n\norigin 是关联名称，可自定义\n后面的地址是github的仓库名称\n\n```angular2\ngit remote add origin git@server-name:path/repo-name.git\n```\n\n13.第一次推送master分支的所有内容\n```angular2\ngit push -u origin master\n```\n\n14.推送内容\n```angular2\ngit push origin master\n```\n\n15.克隆仓库内容\n```angular2\ngit clone\n```\n\n16.创建分支\n\ndev是分支名称可以自定义\n```angular2\ngit branch dev\n```\n\n17.切换分支(2个命令都可以)\n\n```angular2\ngit checkout dev\ngit switch dev\n```\n\n18.查看当前分支\n```angular2\ngit branch\n```\n\n19.分支合并\n\ndev是要合并的分支名称\n```angular2\ngit merge dev\n```\n\n20.删除分支\n\ndev是要删除的分支名称\n```angular2\ngit branch -d dev\n```\n\n21.查看分支合并图\n\n当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n\n解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。\n```angular2\ngit log --graph\n```\n\n21.分支合并,保留合并历史\n\n合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。\n\n```angular2\ngit merge --no-ff -m \"merge with no-ff\" dev\n```\n\n22.保留工作区\n```angular2\ngit stash\n```\n\n23.\n\n### 总结\n\nGit的常用操作可以分为9步\n\n1.初始化仓库\n```angular2\ngit init\n```\n\n2.从远程克隆\n```angular2\ngit clone 要克隆项目的地址\n```\n\n3.和远程库关联\n```angular2\ngit remote add origin git@server-name:path/repo-name.git\n```\n\n4.本地新建分支\n```angular2\ngit branch 分支名称\n```\n\n5.切换分支\n```angular2\ngit checkout 分支名称\n```\n\n6.添加文件到缓存区\n```angular2\ngit add 添加的文件名称\n```\n\n7.提交文件到本地仓库\n```angular2\ngit commit -m 提交说明\n```\n\n8.从远程库拉取代码\n```angular2\ngit pull origin 分支名称\n```\n\n9.本地库的代码提交到远程库\n```angular2\ngit push origin 分支名称\n```\n\n10.git在windows上开发 git add .时 警告warning: LF will be replaced by CRLF in h5/active/shuzhan/js/popup.js.\n```angular2\ngit config --global core.autocrlf false\n```\n这个问题是因为不同平台下的换行符导致的\n\n### 学习文档\n```angular2\nhttps://www.liaoxuefeng.com/wiki/896043488029600/898732864121440\n```\n\n","tags":["面试题"],"categories":["Git"]},{"title":"yum源安装lnmp环境","url":"/2021/04/10/yum源安装lnmp环境/","content":"前言:\n\nlinux安装lnmp环境，有两种方法，分别是:\n\n1.yum源安装(推荐，不用安装项目依赖)\n\n2.官方下载源码包编译安装(不推荐，编译安装容易缺少安装需要的依赖,必须找到对应的依赖才能继续安装)\n\n这篇文章讲的是在Centos7.3系统环境yum源的安装方法\n<!--more-->\n\n### 一、安装Nginx\n安装\n```angular2\nyum install nginx\n```\n启动\n```angular2\nsystemctl start nginx\n```\n### 二、安装php\n安装命令\n```angular2\nyum install php\nyum install php-fpm         //安装php-fpm    \n```\n启动\n```angular2\nsystemctl start php-fpm\n```\nphp-fpm的配置文件梭所在目录:/etc/php-fpm.d/www.conf\n### 三、安装Mysql\n安装命令\n```angular2\nyum install mysql\n```\n\n安装mysql服务端\n```angular2\nsudo rpm -Uvh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm\n```\n\n启动mysql\n```angular2\nsystemctl start mysqld\nsystemctl start mysql\n```\n\n从日志中获取mysql默认密码命令:\n```\ngrep 'temporary password' /var/log/mysqld.log\n```\n\n连接上以后不能进行任何操作，需要修改mysql的密码才可以继续操作:\n```angular2\nALTER USER 'root'@'localhost' IDENTIFIED BY 'Tom579#$%^&';\n```\n\n命令行链接mysql:\n```angular2\nmysql -h 127.0.0.1(连接地址) -u root(账号) -p(密码)\n```\n\n### 四、Nginx和php进行关联\n\nphp和nginx的的2通讯方式,此处采用tcp方式：\n\n1.tcp：ip加端口,可以跨服务器访问\n\n2.UNIX Domain Socket:不可以跨服务器访问，只能访问同一台机器上的\n\n```angular2\nvi /etc/nginx/nginx.conf\n```\n在server里边加上如下参数\n```angular2\nlocation ~ .php$ {\n    fastcgi_pass   0.0.0.0:9000;\n    fastcgi_index  index.php;\n    fastcgi_param  SCRIPT_FILENAME  /www/test$fastcgi_script_name;\n    include        fastcgi_params;\n}\n```\n注:配置完访问php文件报错,Access denied和No input file specified，检查fastcgi_param的参数路径是否配置正确\n\n### 五、php和mysql关联\n安装php-mysql扩展\n```angular2\nyum install php-mysql\n```\n\n### 六、总结\n配合查看命令\n```angular2\nyum list nginx          //查询yum源的nginx列表\nwhich                   //可以查看系统中某个变量是否存在\nps -ef | grep nginx     //检测进程是否启动\nnetstat -antp           //检测端口占用情况\nsystemctl start nginx   //centos7.3启动nginx\n```\n\n\n\n","tags":["面试题"],"categories":["环境搭建","面试题","Linux"]},{"title":"hexo+git搭建个人博客","url":"/2021/04/10/hexo-git搭建个人博客/","content":"###  所需环境：\ngit、npm\n\n###  一、安装环境\n    \n1.安装npm https://nodejs.org/en/\n\n2.安装git https://git-scm.com/downloads\n\n<!--more-->\n\n### 二、安装hexo\n\n```\nnpm install -g hexo-cli\n# 支持图片上传\nnpm install https://github.com/CodeFalling/hexo-asset-image --save\n```\n\n### 三、初始化hexo\nblog为博客目录,可自定义\n```\nhexo init blog\n```\n\n### 四、配置博客信息以及常用命令\n配置信息参考文档：https://hexo.io/zh-cn/docs/configuration\n\nFront-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量\n\n基本操作命令\n```angular2\nhexo new filename       //创建新文件\nhexo server             //运行项目\nhexo clean              //清除项目缓存文件\nhexo generate           //生成静态文件,可简写成 hexo g \nhexo deploy             //推送到git上,可简写成 hexo d\n```\n\n显示图片\n```\nhexo new filename 创建文件后会带一个同名目录，图片放到这个目录下就可以显示了\n![图片描述](图片地址)\n![BP](flex布局/flex.png)\n```\n\n### 五、hexo主题\n当前博客的主题为stum主题,文档地址:https://theme-stun.github.io/docs/zh-CN/guide/quick-start.html\n\n也可以在hexo官网的themes栏目里边找自己心仪的主题\n\n### 六、部署到github\n1.安装 hexo-deployer-git\n```angular2\nnpm install hexo-deployer-git --save\n```\n2.在 _config.yml添加如下配置：\n```angular2\ndeploy:\n  type: git\n  repo: https://github.com/liudongdong2/liudongdong2.github.io.git\n  branch: master\n```\n3.运行 hexo clean && hexo d\n\n4.查看 liudongdong2.github.io 上的网页是否部署成功。\n\n5.自定义博客域名，可以把域名域名以CNAME的方式解析到liudongdong2.github.io上即可\n\n\n\n\n","tags":["hexo","git"],"categories":["环境搭建"]},{"title":"腾讯云Redis外网访问","url":"/2020/11/12/腾讯云Redis外网访问/","content":"### 腾讯云Redis外网访问\n<!--more-->\n腾讯云的Redis实例不能被外网直接访问，需要访问同一个地区的ecs实例，通过内网转发\n\n### Windows服务器转发命令\n```\nnetsh interface portproxy add v4tov4  listenaddress=172.16.0.2 listenport=6379 connectaddress=10.66.144.174 connectport=6379\n\n 参数:\n \n 标记            值\n \n listenport      - IPv4 ecs实例监听的端口\n connectaddress  - IPv4 ecs实例外网访问地址\n connectport     - IPv4 转发到的Redis端口号\n listenaddress   - IPv4 Redis实例的内网地址\n protocol        - 使用的协议。现在只支持 TCP。\n 说明: 添加通过 IPv4 的 IPv4 和代理连接到的侦听项目。\n 参考:https://cloud.tencent.com/developer/article/1142120\n```\n### Linux服务器转发命令\n```\n 没用过\n 参考:https://cloud.tencent.com/document/product/239/39611\n```\n\n\n\n","tags":["Redis"],"categories":["环境"]},{"title":"PHP创建指定范围内的时间段","url":"/2020/11/03/PHP创建指定范围内的时间段/","content":"### 按照小时创建指定范围内的时间段\n<!--more-->\n```\n $arr = [];   \n for($i = 1 ; $i < 4; $i++){\n    for($j = 0 ; $j < 24 ; $j+=2){\n        $arr[] = \n            [\n                'start_time' => '2020-11-'.$i.' '.$j.':00:00',\n                'end_time' => '2020-11-'.$i.' '.($j+2).':00:00'\n            ];\n    }\n}\n```\n#### 按照分钟创建指定范围内的时间段\n```\n for($i = 0 ; $i < 24;$i++){\n    for($j = 0 ; $j <= 40 ; $j+=20){\n        if($j<10){\n            $j = '0'.$j;\n        }\n        $s = $i;\n        $sj = $j+20;\n        if($j == 40){\n            $s = $i+1;\n            $sj = '00';\n        }\n        $arr[] = [\n            'start_time' => '2020-11-01 '.$i.':'.$j.':00',\n            'end_time' => '2020-11-01 '.$s.':'.$sj.':00'\n        ];\n    }\n}\n```","tags":["PHP","常用代码"],"categories":["PHP"]},{"title":"分表思路","url":"/2020/10/26/分表思路/","content":"### 常用的数据库分表方法\n<!--more-->\n分表分为水平分表和垂直分表。\n\n水平分表:根据数据分表\n\n垂直分表:根据字段分表,把不常用的字段、大的字段提出来、分开存储","tags":["mysql","面试题"],"categories":["mysql"]},{"title":"mysql的存储引擎","url":"/2020/10/26/mysql的存储引擎/","content":"MySql的存储引擎,以及各自的区别\n\n### 1.mysql的存储引擎\nInnoDB存储引擎、MyISAM存储引擎、MEMORY存储引擎、ARCHIVE存储引擎、CSV存储引擎\n<!--more-->\n### 2.mysql存储引擎之间的区别\n1、InnoDB存储引擎（支持事务、行级锁、并发相对较好）\n（1）灾难恢复性比较好；\n\n（2）支持事务。默认的事务隔离级别为可重复度，通过MVCC（并发版本控制）来实现的。\n\n（3）使用的锁粒度为行级锁，可以支持更高的并发；\n\n（4）支持外键；\n\n（5）配合一些热备工具可以支持在线热备份；\n\n（6）在InnoDB中存在着缓冲管理，通过缓冲池，将索引和数据全部缓存起来，加快查询的速度；\n\n（7）对于InnoDB类型的表，其数据的物理组织形式是聚簇表。所有的数据按照主键来组织。数据和索引放在一块，都位于B+数的叶子节点上；\n\n2、MyISAM存储引擎（并发性差，不支持事务，表级锁）\n\n（1）不支持事务；\n\n（2）不支持外键，如果强行增加外键，不会提示错误，只是外键不其作用；\n\n（3）对数据的查询缓存只会缓存索引，不会像InnoDB一样缓存数据，而且是利用操作系统本身的缓存；\n\n（4）默认的锁粒度为表级锁，所以并发度很差，加锁快，锁冲突较少，所以不太容易发生死锁；\n\n（5）支持全文索引（MySQL5.6之后，InnoDB存储引擎也对全文索引做了支持），但是MySQL的全文索引基本不会使用，对于全文索引，现在有其他成熟的解决方案，比如：ElasticSearch，Solr，Sphinx等。\n\n（6）数据库所在主机如果宕机，MyISAM的数据文件容易损坏，而且难恢复；\n\n3、MEMORY存储引擎（数据访问速度快）\n将数据存在内存中，和市场上的Redis，memcached等思想类似，为了提高数据的访问速度，主要特点：\n\n（1）支持的数据类型有限制，比如：不支持TEXT和BLOB类型，对于字符串类型的数据，只支持固定长度的行，VARCHAR会被自动存储为CHAR类型；\n\n（2）支持的锁粒度为表级锁。所以，在访问量比较大时，表级锁会成为MEMORY存储引擎的瓶颈；\n\n（3）由于数据是存放在内存中，所以在服务器重启之后，所有数据都会丢失；\n\n（4）查询的时候，如果有用到临时表，而且临时表中有BLOB，TEXT类型的字段，那么这个临时表就会转化为MyISAM类型的表，性能会急剧降低；\n\n4、ARCHIVE存储引擎\nARCHIVE存储引擎适合的场景有限，由于其支持压缩，故主要是用来做日志，流水等数据的归档，主要特点：\n\n（1）支持Zlib压缩，数据在插入表之前，会先被压缩；\n\n（2）仅支持SELECT和INSERT操作，存入的数据就只能查询，不能做修改和删除；\n\n（3）只支持自增键上的索引，不支持其他索引；\n\n5、CSV存储引擎\n数据中转试用，主要特点：\n\n（1）其数据格式为.csv格式的文本，可以直接编辑保存；\n\n（2）导入导出比较方便，可以将某个表中的数据直接导出为csv，使用Excel办公软件打开；\n\n### 3.InnoDB和MyISAM的对比\n1、由于锁粒度的不同，InnoDB比MyISAM支持更高的并发；\n\n2、InnoDB为行级锁，MyISAM为表级锁，所以InnoDB相对于MyISAM来说，更容易发生死锁，锁冲突的概率更大，而且上锁的开销也更大，因为需要为每一行加锁；\n\n3、在备份容灾上，InnoDB支持在线热备，有很成熟的在线热备解决方案；\n\n4、查询性能上，MyISAM的查询效率高于InnoDB，因为InnoDB在查询过程中，是需要维护数据缓存，而且查询过程是先定位到行所在的数据块，然后在从数据块中定位到要查找的行；而MyISAM可以直接定位到数据所在的内存地址，可以直接找到数据；\n\n5、SELECT COUNT(*)语句，如果行数在千万级别以上，MyISAM可以快速查出，而InnoDB查询的特别慢，因为MyISAM将行数单独存储了，而InnoDB需要朱行去统计行数；所以如果使用InnoDB，而且需要查询行数，则需要对行数进行特殊处理，如：离线查询并缓存；\n\n6、MyISAM的表结构文件包括：.frm(表结构定义),.MYI(索引),.MYD(数据)；而InnoDB的表数据文件为:.ibd和.frm(表结构定义)；","tags":["mysql","面试题"],"categories":["mysql"]},{"title":"mysql查询优化","url":"/2020/10/26/mysql查询优化/","content":"mysql查询优化思路\n<!--more-->\n1.常用数据做缓存\n\n2.查询的时候减少不必要字段的返回\n\n3.用索引\n\n4.用join代替子查询\n\n5.UNION语句可以配合limit使用\n\n6.count的时候用*不要用主键\n\n7.数据分页\n","tags":["mysql","面试题"],"categories":["mysql"]},{"title":"mysql读写分离","url":"/2020/10/26/mysql读写分离/","content":"MySql的读写分离概念及应用场景\n\n### 1.场景\n数据量增多，单机的数据库不足以支撑业务，需要用到数据库集群。\n<!--more-->\n### 2.概念\n读写分离，就是将数据库的读和写分离，对应到数据库一般就是主从数据库，一主一从或者一主多从；业务服务器把数据写到主数据库中，读操作都去从库读；主库会同步数据到从库，保证数据的一致性。\n","tags":["mysql","面试题"],"categories":["mysql"]},{"title":"mysql事务","url":"/2020/10/26/mysql事务/","content":"MySql事务\n\n### 1.扁平事务:\n<!--more-->\n是事务类型中最简单的一种，但是在实际生产环境中，这可能是使用最频繁的事务，在扁平事务中，所有操作都处于同一层次，其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束，其间的操作是源自的，要么都执行，要么都回滚，因此扁平事务是应用程序称为原子操作的的基本组成模块\n\n### 2.带有保存点的扁平事务:\n除了支持扁平事务支持的操作外，允许在事务执行过程中回滚同一事务中较早的一个状态。这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销太大，保存点用来通知事务系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。\n\n### 2.带有保存点的扁平事务:\n除了支持扁平事务支持的操作外，允许在事务执行过程中回滚同一事务中较早的一个状态。这是因为某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务不合乎要求，开销太大，保存点用来通知事务系统应该记住事务当前的状态，以便当之后发生错误时，事务能回到保存点当时的状态。\n\n### 3.链事务:\n在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式地传给下一个要开始的事务，提交事务操作和开始下一个事务操作 将合并为一个原子操作，这意味着下一个事务将看到上一个事务的结果\n\n### 4.嵌套事务:\n(1)嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务也可以是扁平事务\n\n(2)处在叶节点的事务是扁平事务，但是每个事务从根到叶节点的距离可以说是不同的\n\n(3)位于根节点的事务称为顶层事务，其他称为自事务。事务的前驱称(predecessor)为父事务(parent)，事务的下一层称为儿子事务(child)\n\n(4)子事务既可以提交也可以回滚。但是它的提交操作并不马上生效。除非其父事务已经提交。因此可以推论出，任何子事务都在顶层事务提交后才真正的提交\n\n(5)树中的任意事务回滚会引起它的所有子事务一同回滚，故子事务仅保留ACI特性而不具有D特性\n\n### 5.分布式事务:\n分布式事务 通常是一个分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点\n\n对于InnoDB存储引擎来说，其支持扁平事务，带保存点的事务，链事务，分布式事务。不支持嵌套事务。\n","tags":["mysql","面试题"],"categories":["mysql"]},{"title":"mysql优化","url":"/2020/10/26/mysql优化/","content":"MySql优化思路\n\n1.选取最合适的字段属性\n<!--more-->\n2.尽量把字段属性设置成not null，执行查询的时候，数据库不用去比较NULL值。\n\n3.对于某些文本字段可以定义成ENUM类型\n\n4.使用连接（JOIN）来代替子查询(Sub-Queries)\n\n5.事务\n\n6.使用联合(UNION)来代替手动创建的临时表\n\n7.使用索引\n\n8.优化查询语句\n","tags":["mysql","面试题"],"categories":["mysql"]},{"title":"mysql索引相关","url":"/2020/10/26/mysql索引相关/","content":"什么是索引?索引的类型有哪些?如何做索引?\n\n### 1.什么是索引?\n```\n索引其实是一种数据结构，其功能是帮助我们快速匹配查找到需要的数据行，是数据库性能优化最常用的工具之一。其作用相当于超市里的导购员、书本里的目录。\n```\n<!--more-->\n\n### 2.索引的类型有哪些?\n```\n主键索引:PRIMARY KEY：它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。注意：一个表只能有一个主键。\n\n唯一索引:UNIQUE：唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一.\n\n普通索引:INDEX：这是最基本的索引，它没有任何限制 \n\n组合索引:INDEX：即一个索引包含多个列，多用于避免回表查询\n\n全文索引:FULLTEXT：也称全文检索，是目前搜索引擎使用的一种关键技术\n```\n### 3.如何做索引\n```\n索引设计的原则\n1）适合索引的列是出现在where子句中的列，或者连接子句中指定的列；\n\n2）基数较小的类，索引效果较差，没有必要在此列建立索引；\n\n3）使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间；\n\n4）不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。\n```","tags":["mysql","面试题"],"categories":["mysql"]},{"title":"NoSql数据库","url":"/2020/10/26/NoSql数据库/","content":"什么是NoSql?常用的NoSql有哪些?\n\n### 1.什么是NoSql?\n```\nNoSQL，指的是非关系型的数据库,是对不同于传统的关系型数据库的数据库管理系统的统称。\n\nNoSQL用于超大规模数据的存储,这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。\n```\n<!--more-->\n\n### 2.NoSql和关系型数据库的区别?\n```\n存储方式、存储结构、存储规范、存储扩展、查询方式、事务、性能\n```\n### 3.常用的关系型数据库\n```\nmysql、sql server、oracle\n```\n### 4.常用的NoSql数据库\n```\nredis、memcache\n```\n\n### 5.redis和memcache的区别?\n```\n1、数据操作不同\n\nMemcached仅支持简单的key-value结构的数据记录\n\nRedis支持的数据类型要丰富的多,字符串、哈希表、链表、集合、有序集合\n\n2.内存管理机制不同\n\n当内存中的值到了一定上限的时候Redis会计算出哪些key对应的value需要swap到磁盘。\n然后再将这些key对应的value持久化到磁盘中，同时在内存中清除。这种特性使得Redis可以保持超过其机器本身内存大小的数据。\n\n而Memcached默认使用Slab Allocation机制管理内存，其主要思想是按照预先规定的大小，将分配的内存分割成特定长度的块以存储相应长度的key-value数据记录\n\n3、性能不同\n\n由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。\n\n而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis也在存储大数据的性能上进行了优化，但是比起Memcached，还是稍有逊色。\n\n4.集群管理不同\n\nMemcached本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现Memcached的分布式存储。\n\n相较于Memcached只能采用客户端实现分布式存储，Redis更偏向于在服务器端构建分布式存储。\n```","tags":["mysql","面试题"],"categories":["mysql"]},{"title":"PSR4是什么","url":"/2020/10/26/PSR4是什么/","content":"PSR-4规范是什么?\n<!--more-->\n```\nPSR 是PHP Standards Recommendation的简称,制定的代码规范，简称PSR，是代码开发的事实标准。\n\nPSR-4使代码更加规范，能够满足面向package的自动加载，它规范了如何从文件路径自动加载类，同时规范了自动加载文件的位置。\n\nPSR原本有四个规范，分别是：\n\nPSR-0 自动加载\n\nPSR-1 基本代码规范\n\nPSR-2 代码样式\n\nPSR-3 日志接口\n\nPSR-4 规范了如何指定文件路径从而自动加载类定义\n\n```\n\n\n","tags":["PHP","面试题"],"categories":["PHP"]},{"title":"Restful Api规范","url":"/2020/10/26/Api规范/","content":"互联网应用程序的API设计理论\n<!--more-->\n```\n1.api与用户之间的协议基于http或者https协议\n\n2.尽量将Api部署到专用域名下\n\n3.应该将API的版本号放入URL。\n\n4.命名规范\n\n5.操作类型GET查询数据POST新增数据PUT修改数据DELETE删除数据\n\n6.服务器向用户返回的状态码和提示信息\n\n7.错误处理\n\n8.返回结果\n``` \n\n### HTTP协议状态码\n\n200 OK [GET]    服务器成功返回用户请求的数据\n\n201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n\n202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n\n204 NO CONTENT - [DELETE]：用户删除数据成功。\n\n400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作\n\n401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）\n\n401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）\n\n404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作\n\n406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n\n410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n\n422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n\n500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n\n","tags":["PHP","面试题"],"categories":["PHP"]},{"title":"PHP的设计原则","url":"/2020/10/26/PHP的设计原则/","content":"利用PHP变成时的设计原则\n<!--more-->\n```\n单一职责:一个类只负责一项职责,降低类的复杂度,提高类的可读性,降低变更的风险性\n\n里氏代换原则：所有引用基类的地方必须能透明地使用其子类的对象，也就是说子类可以扩展父类的功能，但不能改变父类原有的功能\n\n依赖倒置原则:高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。\n\n接口隔离原则：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。\n\n迪米特原则（最少知道原则）：一个对象应该对其他对象保持最少的了解，高内聚，一个类的方法和属性能用私有的就尽量私有化\n\n开闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭，当软件需求变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化\n```\n","tags":["PHP","面试题"],"categories":["PHP"]},{"title":"Session和Cookie","url":"/2020/10/26/Session和Cookie/","content":"Session和Cookie的概念，以及Session、Cookie、Token的区别\n###  1.Session和Cookie的概念\n<!--more-->\n``` bash\n因为http是无状态协议,一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。\n会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。\n```\n\n###  2.什么是Session\n``` bash\nSession是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。\n```\n\n###  3.什么是Cookie\n``` bash\n1、会话Cookie和持久Cookie\n若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在浏览器的不同进程间共享。这种称为持久Cookie。\n\n2、Cookie具有不可跨域名性\n就是说，浏览器访问百度不会带上谷歌的cookie;\n```\n\n###  4.Session和Cookie总结\n``` bash\n1、cookie数据存放在客户的浏览器上，session数据放在服务器上。\n\n2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session。\n\n3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。\n\n4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\n\n5、可以考虑将登陆信息等重要信息存放为session，其他信息如果需要保留，可以放在cookie中。\n```\n\n### 5.session、cookie、token的区别\n```\ntoken验证 把用户信息加密成字符串服务端不存储返回给用户，用户每次请求服务端带着他的token进行解密如果解密成功则认证成功,这样服务端就不用存sessionId了,用cpu计算时间换取了session的存储空间\n```\n\n\n\n","tags":["PHP","面试题"],"categories":["PHP"]},{"title":"PHP的优化方案","url":"/2020/10/26/PHP的优化方案/","content":"PHP的优化方案以及优化思路\n###  1.页面静态化\n\n``` bash\n利用PHP模板生成静态的HTML页面\n```\n<!--more-->\n\n###  2.循环优化\n\n``` bash\n1.禁止在循环内部查询数据库，应将查询放在循环外部。\n\n2.循环内部不宜声明变量，在循环之前预定义需要声明的变量。\n\n3.避免在循环内做运算\n```\n\n\n###  3.其他优化思路\n\n``` bash\n1.如果能将类的方法定义成static，就尽量定义成static\n\n2.require_once()或判重\n\n3.switch好于if\n\n4.除非脚本可以缓存，否则每次调用时都会重新编译一次。引入一套PHP缓存机制通常可以提升25%至100%的性能，以免除编译开销。\n\n5.Apache解析一个PHP脚本的时间要比解析一个静态HTML页面慢2至10倍。尽量多用静态HTML页面，少用脚本。\n\n6.尽量做缓存，减少数据库负载。\n\n7.自写代码冗余较多，可读性不佳，并且性能低，PHP代码越长PHP的执行效率越慢。\n\n8.使用单引号替换双引号，单引号在运行的时候不检查运行引号内部的变量，执行效率是双引号的两倍\n```","tags":["PHP","面试题"],"categories":["PHP"]},{"title":"PHP设计模式","url":"/2020/10/26/PHP设计模式/","content":"你了解设计模式吗？说下你最常用的设计模式\n###  1.单例模式\n\n``` bash\n单例模式顾名思义，就是只有一个实例。作为对象的创建模式， 单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。\n```\n<!--more-->\n\n\n###  2.工厂模式\n\n``` bash\n抽象基类：类中定义抽象一些方法，用以在子类中实现\n\n继承自抽象基类的子类：实现基类中的抽象方法\n\n工厂类：用以实例化所有相对应的子类\n```\n\n###  3.观察者模式\n\n``` bash\n观察者模式属于行为模式，是定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依 赖于它的对象都得到通知并自动刷新。它完美的将观察者对象和被观察者对象分离。可以在独立的对象（主体）中维护一个对主体感兴趣的依赖项（观察器）列表。 让所有观察器各自实现公共的 Observer 接口，以取消主体和依赖性对象之间的直接依赖关系。\n```\n\n### 4.策略模式\n\n``` bash\n在此模式中，算法是从复杂类提取的，因而可以方便地替换。例如，如果要更改搜索引擎中排列页的方法，则策略模式是一个不错的选择。思考一下搜索引擎的几个部分 —— 一部分遍历页面，一部分对每页排列，另一部分基于排列的结果排序。在复杂的示例中，这些部分都在同一个类中。通过使用策略模式，您可将排列部分放入另一个类中，以便更改页排列的方式，而不影响搜索引擎的其余代码.\n```\n\n###  5.适配器模式\n\n``` bash\n把对某些相似的类的操作转化为一个统一的“接口”(这里是比喻的说话)–适配器，或者比喻为一个“界面”，统一或屏蔽了那些类的细节。适配器模式还构造了一种“机制”，使“适配”的类可以很容易的增减，而不用修改与适配器交互的代码，符合“减少代码间耦合”的设计原则。\n```\n\n","tags":["PHP","面试题"],"categories":["PHP"]},{"title":"composer","url":"/2020/10/26/composer/","content":"什么是composer？以及composer是干什么用的？工作原理?\n\n###  什么是Composer？\n\n``` bash\nComposer是PHP的一个依赖管理工具\n```\n<!--more-->\n\n\n###  Composer是干什么用的？\n\n``` bash\n用来处理开发包之间的依赖关系\n```\n\n###  Composer的工作原理？\n\n``` bash\n你有一个项目依赖于若干个库。\n\n其中一些库依赖于其他库。\n\n你声明你所依赖的东西。\n\nComposer 会找出哪个版本的包需要安装，并安装它们（将它们下载到你的项目中）。\n```\n","tags":["PHP","面试题"],"categories":["PHP"]},{"title":"svn环境搭建","url":"/2020/10/26/svn环境搭建/","content":"Linux系统搭建Svn版本控制 ( 系统CentOS 7.2 ) \n\n###  1.安装svn\n\n``` bash\nyum -y install subversion\n```\n<!--more-->\n### 2.创建目录\n``` bash\nmkdir -p /var/svn/project    \n```\n\n### 3.创建仓库\n``` bash\nsvnadmin create /var/svn/project \n```\n\n### 4.设置Svn仓库的提交账户\n``` bash\ncd /var/svn/project\n\nvi authz     \n                       \nuser1=zw                            //设置提交账号,user1为提交账号\n```\n\n### 5.设置Svn仓库的账户密码\n``` bash\nvi passwd    \n              \nuser1=123                            //设置账号密码\n```\n\n### 6.编辑配置文件\n``` bash\nvi svnserve.conf\n\nanon-access = none          //公共权限\n\nauth-access = write         //写权限\n\npassword-db = passwd        //读取passwd的配置\n\nauthz-db = authz            //权限\n\nrealm = /var/svn/project    //project是对应的提交目录名称\n```\n\n### 7.启动Project仓库服务(端口:3690)\n```\nsvnserve -dr /var/svn/project                       //默认启动命令\n\nsvnserve -dr /var/svn/project1 --listen-port 3691   //指定端口号命令\n```\n\n### 8.设置 wx仓库提交检出到 www/wwwroot/web 网站根目录的钩子脚本\n```\ncd /var/svn/wx/hooks\n\ncp post-commit.tmpl post-commit             \n\nchmod a+x post-commit           \n    \nvi post-commit\n\nexport LANG=en_US.UTF-8\n\nsvn up --non-interactive --username user1 --password 123 '/www/wwwroot/project'         //svn提交上来后的检出目录,项目运行目录\n```\n\n### 9.检查Svn启动端口\n```\nnetstat -tunpl|grep svn\n```\n\n### 10.在网站目录下检出仓库代码\n```\nsvn co svn://0.0.0.0 /www/wwwroot/project/        //ip换成真实服务器ip\n```\n\n### 11.windows下检出\n```\nsvn://0.0.0.0:3690        //ip换成服务器ip\n```\n\n### 12.设置SvnServe仓库程序在Linux服务器重启后开机启动\n```\nvi /etc/rc.local\n\n/usr/bin/svnserve -dr /var/svn/wx     //默认端口\n\n/usr/bin/svnserve -dr /var/svn/wx --listen-port 3691    //指定端口\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["Linux","环境搭建"],"categories":["Linux"]},{"title":"PHP获取日期","url":"/2020/10/26/PHP获取日期/","content":"PHP简单获取上月、本月、近15天、近30天的方法\n\n## 示例\n\n### 上月\n\n``` bash\ndate('Ym', strtotime('-1 month')\n```\n<!--more-->\n### 本月\n\n``` bash\ndate('Ym')\n```\n\n### 近一周\n\n``` bash\ndate('Ymd', strtotime(\"-7 day\")\n```\n\n### 昨天\n\n``` bash\ndate('Ymd', strtotime(\"-1 day\")\n```\n### 今天\n\n``` bash\ndate('Ymd')\n```\n\n","tags":["PHP"],"categories":["PHP"]}]